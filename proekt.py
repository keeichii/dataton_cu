# -*- coding: utf-8 -*-
"""proekt.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gNS9WLjRwWMNGHz56Me5s9n_WXnRmXWN
"""

# Import the necessary libraries
import torch
import cv2

data = []
result = []
for i in range(10):
    name2 = str(i+1) + '.png'
    name4 = str(i+1) + '_main.png'
    name1 = cv2.imread(name2, flags=cv2.IMREAD_COLOR)
    name3 = cv2.imread(name4, flags=cv2.IMREAD_COLOR)
    data.append(name1)
    result.append(name3)
#     cv2.imshow("fsedxv", name1)
#     cv2.imshow("fsedx", name3)
    cv2.waitKey(1000)

data1 = [[[0 for i in range(400)] for j in range(400)] for k in range(10)]
for i in range(10):
    for j in range(400):
        for k in range(400):
           data1[i][j][k] = data[i][j][k][0]
print(data1[0][100][100])

result1 = [[[0 for i in range(400)] for j in range(400)] for k in range(10)]
for i in range(10):
    for j in range(400):
        for k in range(400):
           result1[i][j][k] = data[i][j][k][0]
print(result1[9][19][100])

for i in range(10):
    for j in range(20):
        for k in range(20):
            data1 = data1[i][j * 20: (j + 1) * 20][k * 20: (k + 1) * 20]
            result1 = result1[i][j * 20: (j + 1) * 20][k * 20: (k + 1) * 20]

inputs = torch.FloatTensor(data1)
results = torch.tensor(result1)
print(inputs.shape)

print(inputs[0][100][100])
print(results[0][100][100])

# inputs = torch.reshape(inputs, (1000, 40, 40))
print(inputs[0])
# cv2.imshow("fsedxv", inputs[0].numpy())

results = torch.reshape(inputs, (1000, 40, 40))
print(results[0])
# cv2.imshow("fsedxx", results[0].numpy())

dataloader = torch.utils.data.DataLoader(inputs, batch_size = 20, shuffle = False)

class net(torch.nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = torch.nn.Conv2d(1, 8, 3, 1)
        #self.fc2 = torch.nn.Linear(3200, 1600)
        #self.fc3 = torch.nn.Linear(3, 160000)
        self.act1 = torch.nn.LeakyReLU()

        self.conv2 = torch.nn.Conv2d(8, 1, 3, 1)

    def forward(self, x):
#         x = self.fc1(x)
#         x = self.act(x)
#         x = self.fc2(x)
#         x = self.act(x)
#         #x = self.fc3(x)
        #x = self.act(x)

        x = self.conv1(x)
        x = self.act1(x)
        x = self.conv2(x)

        return x

net1 = net()
loss_criterion = torch.nn.MSELoss()
optimizer = torch.optim.Adam(net1.parameters(), lr = 0.001)

for epoch in range(10):
  y_bad = net1.forward(inputs)
  loss = loss_criterion(y_bad, results)
  loss.backward()
  optimizer.step()
  if epoch % 1 == 0:
    print('epoch:', epoch, 'loss:', loss.item())

